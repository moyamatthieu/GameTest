<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSV CORE - v0.9.7 (Mesh Authority)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #020617; font-family: ui-sans-serif, system-ui; color: white; }
        canvas { display: block; }
        #ui-root { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .interactive { pointer-events: auto; }
        #crosshair { 
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; 
            background: rgba(255,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%); 
        }
        .glass { background: rgba(15, 23, 42, 0.85); backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.1); }
        #lock-prompt {
            position: absolute; top: 6px; right: 280px;
            display: none;
        }
    </style>
</head>
<body>

<div id="ui-root">
    <!-- Login Screen -->
    <div id="login-screen" class="interactive absolute inset-0 bg-slate-950 flex items-center justify-center z-50">
        <div class="glass p-8 rounded-2xl w-96 shadow-2xl">
            <h1 class="text-3xl font-black text-blue-500 mb-2 text-center italic tracking-tighter">SSV.NETWORK</h1>
            <p class="text-slate-500 text-[10px] mb-8 text-center uppercase tracking-[0.2em]">Maillage Spatial Distribu√©</p>
            
            <div class="space-y-4">
                <div>
                    <label class="text-[10px] text-slate-400 uppercase font-bold ml-1">Identifiant N≈ìud</label>
                    <input id="username" type="text" placeholder="ex: node_alpha" 
                        class="w-full p-3 bg-slate-800/50 text-white rounded-lg border border-slate-700 focus:border-blue-500 outline-none transition-all">
                </div>
                <div id="admin-fields" class="hidden">
                    <label class="text-[10px] text-red-400 uppercase font-bold ml-1">Cl√© G√©sine (Root)</label>
                    <input id="password" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" 
                        class="w-full p-3 bg-red-900/10 text-white rounded-lg border border-red-900/30 focus:border-red-500 outline-none">
                </div>
                <button id="btn-join" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 rounded-lg shadow-lg shadow-blue-900/20 transition-all uppercase text-sm tracking-widest">
                    Initialiser la Connexion
                </button>
                <p class="text-[9px] text-slate-500 text-center cursor-pointer hover:text-white" onclick="document.getElementById('admin-fields').classList.toggle('hidden')">
                    Acc√®s Super Architecte ?
                </p>
            </div>
        </div>
    </div>

    <!-- HUD / Dashboard -->
    <div id="hud" class="hidden absolute top-6 left-6 pointer-events-none">
        <div class="glass p-4 rounded-xl min-w-[220px] space-y-3">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-2">
                    <div id="status-dot" class="w-2 h-2 rounded-full bg-red-500 animate-pulse"></div>
                    <span id="user-display" class="font-bold text-xs uppercase tracking-tight">N≈ìud inconnu</span>
                </div>
                <span id="role-tag" class="text-[9px] px-2 py-0.5 rounded bg-slate-800 text-slate-400 uppercase font-bold">Observer</span>
            </div>
            
            <div class="grid grid-cols-2 gap-2 pt-2 border-t border-white/5">
                <div class="flex flex-col">
                    <span class="text-[9px] text-slate-500 uppercase">Pairs Actifs</span>
                    <span id="stats-peers" class="text-blue-400 font-mono font-bold">0</span>
                </div>
                <div class="flex flex-col">
                    <span class="text-[9px] text-slate-500 uppercase">√âtat Monde</span>
                    <span id="stats-entities" class="text-green-400 font-mono font-bold">0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Control Room (Super Architecte Only) -->
    <div id="control-room" class="hidden interactive absolute top-6 right-6 w-64">
        <div class="glass p-4 rounded-xl space-y-4 border-red-500/20">
            <h2 class="text-red-500 text-[10px] font-black uppercase tracking-widest border-b border-red-500/10 pb-2">Control Room</h2>
            
            <div class="space-y-2">
                <label class="text-[10px] text-slate-400">Gravit√© Universelle</label>
                <input type="range" id="slider-gravity" min="0" max="20" value="9" class="w-full accent-red-500">
            </div>

            <button id="btn-force-sync" class="w-full bg-red-950/50 hover:bg-red-900 border border-red-800 text-red-400 text-[10px] font-bold py-2 rounded uppercase">
                Forcer Synchronisation
            </button>
            
            <div id="mesh-log" class="h-32 overflow-y-auto text-[9px] font-mono text-slate-500 bg-black/30 p-2 rounded border border-white/5">
                > Initialisation kernel...
            </div>
        </div>
    </div>

    <div id="lock-prompt" class="glass p-3 rounded-xl border-blue-500/30" style="display: none;">
        <p class="text-blue-400 font-bold uppercase tracking-widest text-[10px]">Mode Observer</p>
        <p class="text-slate-400 text-[9px]">Cliquez pour contr√¥ler</p>
    </div>
    
    <div id="crosshair"></div>
</div>

<script>
/**
 * SSV CORE v0.9.7 - ENGINE
 * Impl√©mentation du Manifeste : Quorum, Recettes JSON et Autorit√©.
 */

const CONFIG = {
    APP_PREFIX: "SSV-MESH-X97-",
    DISCOVERY_NODES: ['admin', 'node0', 'node1', 'node2', 'node3', 'node4', 'node5'],
    GRID_SIZE: 1000,
    CHUNK_SIZE: 16,
    BROADCAST_MS: 45,
    // Utilise l'origine actuelle pour supporter les codespaces et environnements distants
    BACKUP_SERVER: window.location.origin + '/api/backup',
    AUTOSAVE_INTERVAL: 30000 // 30 secondes
};

const Persistence = {
    // ===== DONN√âES PERSONNELLES DU JOUEUR =====
    
    // G√©n√©rer la cl√© de stockage unique pour un joueur
    getPlayerKey(username) {
        return `ssv_player_${username || State.username}`;
    },

    // Sauvegarder les donn√©es personnelles du joueur
    savePlayer() {
        try {
            if (!State.username) return null;
            
            const playerData = {
                username: State.username,
                color: State.myColor,
                lastPosition: Engine.player ? {
                    x: Engine.player.position.x,
                    y: Engine.player.position.y,
                    z: Engine.player.position.z
                } : { x: 0, y: 0, z: 0 },
                lastSeen: Date.now()
            };
            // Cl√© unique par joueur : ssv_player_node0, ssv_player_node1, etc.
            const key = this.getPlayerKey();
            localStorage.setItem(key, JSON.stringify(playerData));
            console.log(`üë§ Joueur sauvegard√©: ${playerData.username} (${key})`);
            return playerData;
        } catch (e) {
            console.error('‚ùå Erreur sauvegarde joueur:', e);
            return null;
        }
    },

    // Charger les donn√©es personnelles du joueur (par username)
    loadPlayer(username) {
        try {
            const key = this.getPlayerKey(username);
            const data = localStorage.getItem(key);
            if (data) {
                const parsed = JSON.parse(data);
                console.log(`üë§ Joueur charg√©: ${parsed.username} (${key})`);
                return parsed;
            }
        } catch (e) {
            console.error('‚ùå Erreur chargement joueur:', e);
        }
        return null;
    },

    // ===== DONN√âES DU MONDE (LOCAL) =====
    
    // Sauvegarder le monde dans localStorage
    saveWorldLocal() {
        try {
            const worldData = Array.from(State.worldRegistry.values()).map(v => v.recipe);
            const data = {
                version: "0.9.7",
                world: worldData,
                timestamp: Date.now(),
                author: State.username,
                playerColors: Array.from(State.playerColors.entries()),
                laws: {
                    gravity: State.gravity
                }
            };
            localStorage.setItem('ssv_world', JSON.stringify(data));
            console.log(`üíæ Monde local: ${worldData.length} entit√©s sauvegard√©es`);
            return data;
        } catch (e) {
            console.error('‚ùå Erreur sauvegarde monde local:', e);
            return null;
        }
    },

    // Charger le monde depuis localStorage
    loadWorldLocal() {
        try {
            const data = localStorage.getItem('ssv_world');
            if (data) {
                const parsed = JSON.parse(data);
                console.log(`üì¶ Monde local: ${parsed.world.length} entit√©s charg√©es`);
                return parsed;
            }
        } catch (e) {
            console.error('‚ùå Erreur chargement monde local:', e);
        }
        return null;
    },

    // ===== BACKUP SERVEUR (GLOBAL) =====
    
    // Construire les donn√©es de spawn de tous les joueurs connus
    buildPlayerSpawns() {
        const spawns = {};
        
        // Ma propre position
        if (Engine.player) {
            spawns[State.username] = {
                x: Engine.player.position.x,
                y: Engine.player.position.y,
                z: Engine.player.position.z,
                color: State.myColor,
                lastSeen: Date.now()
            };
        }
        
        // Positions des autres joueurs (avatars visibles)
        State.avatars.forEach((avatar, peerId) => {
            const name = peerId.replace(CONFIG.APP_PREFIX, "");
            spawns[name] = {
                x: avatar.position.x,
                y: avatar.position.y,
                z: avatar.position.z,
                color: State.playerColors.get(peerId) || 0xffffff,
                lastSeen: Date.now()
            };
        });
        
        return spawns;
    },

    // Sauvegarder sur le serveur (backup global)
    async saveServer(worldData) {
        try {
            const backupData = {
                version: "0.9.7",
                savedAt: new Date().toISOString(),
                author: State.username,
                
                // √âtat du monde
                world: worldData.world || [],
                
                // Positions de spawn des joueurs (pas live, mais derni√®re position connue)
                playerSpawns: this.buildPlayerSpawns(),
                
                // Couleurs des joueurs
                playerColors: Array.from(State.playerColors.entries()),
                
                // Lois du monde
                laws: {
                    gravity: State.gravity
                }
            };

            const response = await fetch(CONFIG.BACKUP_SERVER, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(backupData)
            });
            
            if (response.ok) {
                const playerCount = Object.keys(backupData.playerSpawns).length;
                console.log(`‚òÅÔ∏è  Backup serveur: ${backupData.world.length} entit√©s, ${playerCount} joueurs`);
            }
        } catch (e) {
            console.warn('‚ö†Ô∏è  Backup serveur √©chou√© (normal si offline):', e.message);
        }
    },

    // Charger depuis le serveur (fallback)
    async loadServer() {
        try {
            const response = await fetch(CONFIG.BACKUP_SERVER);
            if (response.ok) {
                const data = await response.json();
                if (data.world && data.world.length > 0) {
                    console.log(`‚òÅÔ∏è  Serveur: ${data.world.length} entit√©s, ${Object.keys(data.playerSpawns || {}).length} spawns`);
                    return data;
                }
            }
        } catch (e) {
            console.warn('‚ö†Ô∏è  Serveur backup inaccessible (normal si offline):', e.message);
        }
        return null;
    },

    // ===== STRAT√âGIES DE CHARGEMENT =====
    
    // R√©conciliation des donn√©es (timestamp le plus r√©cent gagne)
    reconcile(localData, serverData) {
        if (!localData && !serverData) return null;
        if (!localData) return serverData;
        if (!serverData) return localData;
        
        // Le plus r√©cent gagne pour la base
        const baseData = (localData.timestamp || 0) > (serverData.timestamp || 0) ? localData : serverData;
        
        // Fusionner les entit√©s du monde (plus r√©cent par entit√©)
        const mergedWorld = new Map();
        
        [localData, serverData].forEach(source => {
            if (source && source.world) {
                source.world.forEach(entity => {
                    const existing = mergedWorld.get(entity.id);
                    if (!existing || (entity.ts || 0) > (existing.ts || 0)) {
                        mergedWorld.set(entity.id, entity);
                    }
                });
            }
        });
        
        return {
            ...baseData,
            world: Array.from(mergedWorld.values()),
            timestamp: Date.now()
        };
    },

    // Charger le monde (strat√©gie intelligente)
    async loadWorld() {
        // 1. Charger les deux sources
        const localData = this.loadWorldLocal();
        let serverData = null;
        
        // 2. Essayer le serveur si local vide ou pour r√©conciliation
        if (!localData || !localData.world || localData.world.length === 0) {
            console.log('üì• Local vide, tentative serveur...');
            serverData = await this.loadServer();
        }
        
        // 3. R√©concilier si n√©cessaire
        const data = this.reconcile(localData, serverData);
        
        // 4. Appliquer les donn√©es
        if (data && data.world) {
            data.world.forEach(recipe => Network.commitToWorld(recipe));
            
            // Restaurer les couleurs
            if (data.playerColors) {
                data.playerColors.forEach(([key, value]) => {
                    State.playerColors.set(key, value);
                });
            }
            
            // Restaurer les lois
            if (data.laws) {
                State.gravity = data.laws.gravity || 9.81;
            }
            
            console.log(`‚úÖ Monde charg√©: ${data.world.length} entit√©s`);
            return data;
        }
        
        console.log('üÜï Nouveau monde (aucune sauvegarde trouv√©e)');
        return null;
    },

    // ===== ACTIONS DE SAUVEGARDE =====
    
    // Sauvegarde rapide (locale uniquement)
    saveQuick() {
        this.savePlayer();
        return this.saveWorldLocal();
    },

    // Sauvegarde compl√®te (local + serveur si autoris√©)
    async saveFull() {
        this.savePlayer();
        const worldData = this.saveWorldLocal();
        
        // Backup serveur si admin OU si dernier joueur
        const shouldBackupServer = State.isArchitect || this.isLastPlayer();
        
        if (worldData && shouldBackupServer) {
            await this.saveServer(worldData);
        }
        
        return worldData;
    },

    // V√©rifier si on est le dernier joueur (pour backup d'urgence)
    isLastPlayer() {
        return State.connections.size === 0 && State.isInitialized;
    },

    // ===== LEGACY COMPATIBILITY =====
    
    // Anciennes m√©thodes pour compatibilit√©
    saveLocal() { return this.saveQuick(); },
    loadLocal() { return this.loadWorldLocal(); },
    async load() { return this.loadWorld(); },
    async save() { return this.saveFull(); }
};

/**
 * SaveTrigger - Syst√®me de sauvegarde intelligent
 * G√®re quand et comment sauvegarder bas√© sur plusieurs crit√®res
 */
const SaveTrigger = {
    // Configuration des seuils
    config: {
        // Distance
        distanceThreshold: 5,          // Sauvegarder tous les 5 m√®tres parcourus
        
        // Temps
        timeIntervalIdle: 60000,       // 60s si inactif
        timeIntervalActive: 30000,     // 30s si actif
        
        // Actions (priorit√©s)
        actionPriority: {
            build: 'immediate',         // Construction = sauvegarde imm√©diate
            destroy: 'immediate',       // Destruction = sauvegarde imm√©diate
            inventory: 'deferred',      // Inventaire = sauvegarde diff√©r√©e (batch)
            move: 'threshold',          // Mouvement = sauvegarde par seuil de distance
            idle: 'interval'            // Inactif = sauvegarde par intervalle
        },
        
        // Anti-spam
        minSaveInterval: 2000,          // Minimum 2s entre sauvegardes
        batchDelay: 5000                // D√©lai pour actions "deferred" (5s)
    },
    
    // √âtat du tracker
    state: {
        lastSaveTime: 0,
        lastPosition: { x: 0, y: 0, z: 0 },
        distanceSinceLastSave: 0,
        pendingActions: [],
        batchTimeout: null,
        isActive: false,
        actionCount: 0
    },
    
    // Initialiser le syst√®me
    init() {
        console.log('‚è±Ô∏è SaveTrigger initialis√©');
        this.state.lastSaveTime = Date.now();
        
        // Timer adaptatif (v√©rifie toutes les 5 secondes)
        setInterval(() => this.checkTimeTrigger(), 5000);
    },
    
    // Mettre √† jour la position et v√©rifier le seuil de distance
    updatePosition(newPos) {
        if (!this.state.lastPosition) {
            this.state.lastPosition = { ...newPos };
            return;
        }
        
        // Calculer la distance parcourue
        const dx = newPos.x - this.state.lastPosition.x;
        const dy = newPos.y - this.state.lastPosition.y;
        const dz = newPos.z - this.state.lastPosition.z;
        const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
        
        this.state.distanceSinceLastSave += distance;
        this.state.lastPosition = { ...newPos };
        this.state.isActive = distance > 0.01;
        
        // Seuil de distance atteint ?
        if (this.state.distanceSinceLastSave >= this.config.distanceThreshold) {
            this.triggerSave('distance', `${this.state.distanceSinceLastSave.toFixed(1)}m parcourus`);
            this.state.distanceSinceLastSave = 0;
        }
    },
    
    // Enregistrer une action
    recordAction(actionType, data = {}) {
        const priority = this.config.actionPriority[actionType] || 'deferred';
        this.state.actionCount++;
        
        switch (priority) {
            case 'immediate':
                // Sauvegarde imm√©diate (construction, destruction)
                this.triggerSave('action', `Action: ${actionType}`);
                break;
                
            case 'deferred':
                // Accumuler et sauvegarder en batch
                this.state.pendingActions.push({ type: actionType, data, time: Date.now() });
                this.scheduleBatchSave();
                break;
                
            case 'threshold':
                // G√©r√© par updatePosition()
                break;
                
            case 'interval':
                // G√©r√© par checkTimeTrigger()
                break;
        }
    },
    
    // Programmer une sauvegarde batch (pour actions diff√©r√©es)
    scheduleBatchSave() {
        if (this.state.batchTimeout) return; // D√©j√† programm√©
        
        this.state.batchTimeout = setTimeout(() => {
            const count = this.state.pendingActions.length;
            if (count > 0) {
                this.triggerSave('batch', `${count} actions en attente`);
                this.state.pendingActions = [];
            }
            this.state.batchTimeout = null;
        }, this.config.batchDelay);
    },
    
    // V√©rifier le trigger temporel
    checkTimeTrigger() {
        const now = Date.now();
        const elapsed = now - this.state.lastSaveTime;
        const interval = this.state.isActive 
            ? this.config.timeIntervalActive 
            : this.config.timeIntervalIdle;
        
        if (elapsed >= interval) {
            const mode = this.state.isActive ? 'actif' : 'inactif';
            this.triggerSave('time', `Intervalle ${mode} (${Math.round(elapsed/1000)}s)`);
        }
    },
    
    // D√©clencher une sauvegarde
    triggerSave(reason, details = '') {
        const now = Date.now();
        
        // Anti-spam : respecter l'intervalle minimum
        if (now - this.state.lastSaveTime < this.config.minSaveInterval) {
            console.log(`‚è≥ Sauvegarde ignor√©e (anti-spam): ${reason}`);
            return false;
        }
        
        this.state.lastSaveTime = now;
        
        // Log d√©taill√©
        console.log(`üíæ Sauvegarde [${reason}]: ${details}`);
        
        // Ex√©cuter la sauvegarde appropri√©e
        switch (reason) {
            case 'action':
                // Actions critiques = sauvegarde compl√®te
                Persistence.saveFull();
                break;
                
            case 'distance':
            case 'time':
            case 'batch':
                // Autres = sauvegarde rapide
                Persistence.saveQuick();
                break;
                
            default:
                Persistence.saveQuick();
        }
        
        return true;
    },
    
    // Forcer une sauvegarde imm√©diate (fermeture, urgence)
    forceImmediate(reason = 'forced') {
        console.log(`üö® Sauvegarde forc√©e: ${reason}`);
        this.state.lastSaveTime = 0; // Bypass anti-spam
        Persistence.saveQuick();
    },
    
    // Obtenir les statistiques
    getStats() {
        return {
            lastSave: new Date(this.state.lastSaveTime).toLocaleTimeString(),
            distanceSinceLastSave: this.state.distanceSinceLastSave.toFixed(1) + 'm',
            pendingActions: this.state.pendingActions.length,
            totalActions: this.state.actionCount,
            isActive: this.state.isActive
        };
    }
};

const State = {
    peer: null,
    username: "",
    isArchitect: false,
    myColor: null, // Ma couleur personnelle
    playerColors: new Map(), // peerId -> couleur
    connections: new Map(),
    avatars: new Map(),
    worldRegistry: new Map(), // Registre des "Recettes" (ID -> Data)
    gravity: 9.81,
    velocityY: 0,
    isGrounded: true,
    isInitialized: false,
    isTabActive: true
};

const Engine = {
    scene: null, camera: null, renderer: null, worldGroup: null, player: null,
    cameraData: {
        yaw: 0, pitch: -0.3, distance: 8, targetDistance: 8, heightOffset: 1.5,
        minPitch: -1.4, maxPitch: 0.2
    },

    init() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x020617);
        this.scene.fog = new THREE.FogExp2(0x020617, 0.015);
        
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        document.body.appendChild(this.renderer.domElement);

        // Lights
        this.scene.add(new THREE.AmbientLight(0x404040, 0.6));
        const sun = new THREE.DirectionalLight(0xffffff, 1.0);
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        this.scene.add(sun);

        // Ground Grid
        const grid = new THREE.GridHelper(CONFIG.GRID_SIZE, 100, 0x1e293b, 0x0f172a);
        this.scene.add(grid);

        this.worldGroup = new THREE.Group();
        this.scene.add(this.worldGroup);

        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });

        this.animate();
    },

    createAvatar(color, name = "Pair") {
        const group = new THREE.Group();
        // Body
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.4), new THREE.MeshStandardMaterial({ color, roughness: 0.3 }));
        body.position.y = 0.6;
        body.castShadow = true;
        group.add(body);
        
        // Head
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshStandardMaterial({ color: 0xffffff }));
        head.position.y = 1.45;
        group.add(head);

        // Nametag (Canvas-based simple sprite)
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 256; canvas.height = 64;
        ctx.fillStyle = 'white'; ctx.font = 'bold 32px Inter, sans-serif';
        ctx.textAlign = 'center'; ctx.fillText(name, 128, 48);
        const tex = new THREE.CanvasTexture(canvas);
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex }));
        sprite.position.y = 2.2;
        sprite.scale.set(1.5, 0.375, 1);
        group.add(sprite);

        return group;
    },

    animate() {
        requestAnimationFrame(() => this.animate());
        // Le jeu continue m√™me si pointer lock rel√¢ch√©, pause uniquement si changement d'onglet
        if (!State.isInitialized || !State.isTabActive) return;
        
        Network.processPhysics();
        
        if (this.player) {
            this.cameraData.distance += (this.cameraData.targetDistance - this.cameraData.distance) * 0.1;
            const offsetX = this.cameraData.distance * Math.sin(this.cameraData.yaw) * Math.cos(this.cameraData.pitch);
            const offsetZ = this.cameraData.distance * Math.cos(this.cameraData.yaw) * Math.cos(this.cameraData.pitch);
            const offsetY = -this.cameraData.distance * Math.sin(this.cameraData.pitch);
            
            this.camera.position.lerp(new THREE.Vector3(
                this.player.position.x + offsetX,
                this.player.position.y + this.cameraData.heightOffset + offsetY,
                this.player.position.z + offsetZ
            ), 0.15);
            this.camera.lookAt(this.player.position.clone().add(new THREE.Vector3(0, 1.2, 0)));
        }
        this.renderer.render(this.scene, this.camera);
    }
};

const Network = {
    keys: {},
    async init(username) {
        State.username = username.toLowerCase();
        State.isInitialized = true;
        
        // G√©n√©rer ma couleur unique
        State.myColor = this.getHashColor(State.username);
        State.playerColors.set(CONFIG.APP_PREFIX + State.username, State.myColor);
        
        document.getElementById('user-display').innerText = State.username;
        if (State.isArchitect) {
            document.getElementById('role-tag').innerText = "Root";
            document.getElementById('role-tag').classList.replace('bg-slate-800', 'bg-red-600');
            document.getElementById('role-tag').classList.replace('text-slate-400', 'text-white');
            document.getElementById('control-room').classList.remove('hidden');
        }

        Engine.player = Engine.createAvatar(State.myColor, State.username);
        Engine.scene.add(Engine.player);

        // Charger les donn√©es du joueur (position de spawn) - avec le username actuel
        const playerData = Persistence.loadPlayer(State.username);
        if (playerData && playerData.lastPosition) {
            Engine.player.position.set(
                playerData.lastPosition.x,
                playerData.lastPosition.y,
                playerData.lastPosition.z
            );
            console.log(`üìç Position restaur√©e pour ${State.username}: (${playerData.lastPosition.x.toFixed(1)}, ${playerData.lastPosition.y.toFixed(1)}, ${playerData.lastPosition.z.toFixed(1)})`);
        } else {
            console.log(`üÜï Nouveau joueur ${State.username}, position par d√©faut`);
        }

        // Charger le monde sauvegard√©
        const worldData = await Persistence.loadWorld();
        
        // Si on a des spawns du serveur, proposer de s'y t√©l√©porter
        if (worldData && worldData.playerSpawns && worldData.playerSpawns[State.username]) {
            const spawn = worldData.playerSpawns[State.username];
            console.log(`üéØ Spawn serveur disponible pour ${State.username}`);
        }

        State.peer = new Peer(CONFIG.APP_PREFIX + State.username);
        State.peer.on('open', (id) => {
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('status-dot').classList.replace('bg-red-500', 'bg-green-500');
            this.log(`Node OK : ${id}`);
            this.gossip();
            setInterval(() => this.gossip(), 5000);
            
            // Initialiser le syst√®me de sauvegarde intelligent
            SaveTrigger.init();
        });

        State.peer.on('connection', (conn) => this.bindEvents(conn));
        
        // G√©rer l'√©v√©nement de kick (identifiant dupliqu√©)
        State.peer.on('error', (err) => {
            if (err.type === 'peer-unavailable') {
                // Peer non disponible, normal
            } else {
                console.error('Erreur PeerJS:', err);
            }
        });

        // Input Bindings
        window.addEventListener('keydown', (e) => this.keys[e.code] = true);
        window.addEventListener('keyup', (e) => this.keys[e.code] = false);
        
        // Pause uniquement si on change d'onglet (pas si souris quitte la fen√™tre)
        document.addEventListener('visibilitychange', () => {
            State.isTabActive = !document.hidden;
            if (document.hidden) {
                this.keys = {}; // R√©initialiser les touches si on quitte l'onglet
                SaveTrigger.forceImmediate('tab_hidden'); // Sauvegarde forc√©e
            }
        });
        
        // Sauvegarde avant fermeture de la page
        window.addEventListener('beforeunload', () => {
            SaveTrigger.forceImmediate('page_unload'); // Sauvegarde forc√©e
        });
        
        // G√©rer le changement de pointer lock (√âchap lib√®re la souris)
        document.addEventListener('pointerlockchange', () => {
            this.updateLockUI();
            // R√©initialiser les touches quand on lib√®re le contr√¥le
            if (document.pointerLockElement !== Engine.renderer.domElement) {
                this.keys = {};
            }
        });

        window.addEventListener('mousedown', (e) => {
            if (document.pointerLockElement !== Engine.renderer.domElement) {
                Engine.renderer.domElement.requestPointerLock();
                return; 
            }
            this.requestAction('build');
        });

        window.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === Engine.renderer.domElement) {
                Engine.cameraData.yaw += e.movementX * 0.003;
                Engine.cameraData.pitch = Math.max(
                    Engine.cameraData.minPitch, 
                    Math.min(Engine.cameraData.maxPitch, Engine.cameraData.pitch + e.movementY * 0.003)
                );
            }
        });

        // Admin controls
        document.getElementById('slider-gravity').oninput = (e) => {
            const val = parseFloat(e.target.value) / 10;
            this.broadcast({ type: 'law', key: 'gravity', value: val });
        };
    },

    updateLockUI() {
        const prompt = document.getElementById('lock-prompt');
        const crosshair = document.getElementById('crosshair');
        const isLocked = document.pointerLockElement === Engine.renderer.domElement;
        
        // Afficher le prompt et masquer le crosshair seulement si d√©verrouill√©
        prompt.style.display = isLocked ? 'none' : 'block';
        crosshair.style.display = isLocked ? 'block' : 'none';
    },

    log(msg) {
        const log = document.getElementById('mesh-log');
        log.innerHTML += `<div>> ${msg}</div>`;
        log.scrollTop = log.scrollHeight;
    },

    // LE QUORUM : On ne construit pas tout de suite, on demande au maillage
    requestAction(type) {
        if (type === 'build') {
            const dir = new THREE.Vector3();
            Engine.camera.getWorldDirection(dir);
            const pos = new THREE.Vector3().copy(Engine.player.position).add(dir.multiplyScalar(4));
            
            const recipe = {
                id: `ent_${Math.random().toString(36).substr(2, 9)}`,
                t: 'block',
                p: { x: Math.round(pos.x), y: Math.round(pos.y), z: Math.round(pos.z) },
                c: State.isArchitect ? 0xef4444 : this.getHashColor(State.username),
                creator: State.username,
                ts: Date.now()
            };

            this.log(`Intention: ${recipe.id}`);
            // Envoi de l'intention aux pairs pour validation (Quorum de voisinage)
            this.broadcast({ type: 'intent_build', recipe });
            // Optimistic rendering (on le place pour nous, mais il peut dispara√Ætre si rejet√©)
            this.commitToWorld(recipe);
            
            // üîî D√©clencher sauvegarde (action critique)
            SaveTrigger.recordAction('build', { recipeId: recipe.id });
        }
    },

    commitToWorld(recipe) {
        if (State.worldRegistry.has(recipe.id)) return;
        
        const geo = new THREE.BoxGeometry(1, 1, 1);
        const mat = new THREE.MeshStandardMaterial({ color: recipe.c });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(recipe.p.x, recipe.p.y, recipe.p.z);
        mesh.castShadow = mesh.receiveShadow = true;
        
        Engine.worldGroup.add(mesh);
        State.worldRegistry.set(recipe.id, { mesh, recipe });
        document.getElementById('stats-entities').innerText = State.worldRegistry.size;
    },

    processPhysics() {
        if (!Engine.player) return;
        
        // Vitesse de base et course (Shift)
        const baseSpeed = 0.12;
        const sprintMultiplier = this.keys['ShiftLeft'] || this.keys['ShiftRight'] ? 1.8 : 1;
        const speed = baseSpeed * sprintMultiplier;
        
        const move = new THREE.Vector3();
        if (this.keys['KeyW'] || this.keys['KeyZ']) move.z -= 1;
        if (this.keys['KeyS']) move.z += 1;
        if (this.keys['KeyA'] || this.keys['KeyQ']) move.x -= 1;
        if (this.keys['KeyD']) move.x += 1;

        if (move.length() > 0) {
            move.normalize();
            // Appliquer la rotation de la cam√©ra au vecteur de mouvement
            move.applyAxisAngle(new THREE.Vector3(0, 1, 0), Engine.cameraData.yaw);
            Engine.player.position.add(move.multiplyScalar(speed));
            // Orienter le personnage dans la direction du mouvement
            Engine.player.rotation.y = Math.atan2(move.x, move.z);
        }
        
        // Saut (Espace)
        if ((this.keys['Space']) && State.isGrounded) {
            State.velocityY = 0.25;
            State.isGrounded = false;
        }
        
        // Gravit√© et physique verticale
        State.velocityY -= State.gravity * 0.002;
        Engine.player.position.y += State.velocityY;
        
        // Collision avec le sol
        if (Engine.player.position.y <= 0) {
            Engine.player.position.y = 0;
            State.velocityY = 0;
            State.isGrounded = true;
        }

        // üîî Tracker la position pour le syst√®me de sauvegarde
        SaveTrigger.updatePosition({
            x: Engine.player.position.x,
            y: Engine.player.position.y,
            z: Engine.player.position.z
        });

        this.broadcast({ 
            type: 'pos', 
            p: { x: Engine.player.position.x, y: Engine.player.position.y, z: Engine.player.position.z }, 
            r: Engine.player.rotation.y,
            color: State.myColor
        });
    },

    broadcast(data) {
        State.connections.forEach(conn => { if (conn.open) conn.send(data); });
    },

    bindEvents(conn) {
        conn.on('open', () => {
            State.connections.set(conn.peer, conn);
            document.getElementById('stats-peers').innerText = State.connections.size;
            this.log(`Peer connect√©: ${conn.peer.replace(CONFIG.APP_PREFIX, "")}`);
            
            // V√©rifier les identifiants dupliqu√©s
            const remoteName = conn.peer.replace(CONFIG.APP_PREFIX, "");
            const myName = State.username;
            
            // Si quelqu'un a le m√™me nom que moi, je kick l'ancien (moi)
            if (remoteName === myName) {
                this.log(`‚ö†Ô∏è Identifiant dupliqu√© d√©tect√©: ${remoteName}`);
                // Le nouveau me kick (je suis l'ancien)
                setTimeout(() => {
                    alert(`Un autre joueur s'est connect√© avec votre identifiant "${myName}".\nVous avez √©t√© d√©connect√©.`);
                    location.reload();
                }, 500);
                return;
            }
            
            // Envoyer mon identit√© avec ma couleur
            conn.send({ type: 'identity', username: myName, color: State.myColor });
            
            // Sync initial du monde
            if (State.worldRegistry.size > 0) {
                const worldState = Array.from(State.worldRegistry.values()).map(v => v.recipe);
                conn.send({ type: 'sync_world', data: worldState });
            }
            
            // Partager ma liste de pairs connus (d√©couverte transitive)
            if (State.connections.size > 1) {
                const knownPeers = Array.from(State.connections.keys());
                conn.send({ 
                    type: 'peer_discovery', 
                    peers: knownPeers,
                    origin: CONFIG.APP_PREFIX + State.username
                });
            }
        });
        
        conn.on('data', (data) => {
            switch(data.type) {
                case 'pos': 
                    // Mettre √† jour la couleur si fournie
                    if (data.color) {
                        State.playerColors.set(conn.peer, data.color);
                    }
                    this.handleRemotePos(conn.peer, data); 
                    break;
                case 'intent_build': this.commitToWorld(data.recipe); break;
                case 'sync_world': data.data.forEach(r => this.commitToWorld(r)); break;
                case 'identity':
                    // Un pair m'informe de son identit√©
                    // Stocker sa couleur
                    if (data.color) {
                        State.playerColors.set(conn.peer, data.color);
                    }
                    // Si c'est le m√™me que le mien, je suis l'ancien, je me d√©connecte
                    if (data.username === State.username) {
                        this.log(`‚ö†Ô∏è Collision d'identifiant avec ${conn.peer}`);
                        alert(`Un autre joueur utilise l'identifiant "${State.username}".\nVous allez √™tre d√©connect√©.`);
                        setTimeout(() => location.reload(), 1000);
                    }
                    break;
                case 'peer_discovery':
                    // Un pair me partage sa liste de pairs connus
                    if (data.peers && Array.isArray(data.peers)) {
                        data.peers.forEach(peerId => this.discoverPeer(peerId));
                    }
                    break;
                case 'law': 
                    if (conn.peer.includes('admin')) {
                        State[data.key] = data.value;
                        this.log(`Loi modifi√©e: ${data.key} = ${data.value}`);
                    }
                    break;
            }
        });

        conn.on('close', () => {
            State.connections.delete(conn.peer);
            const av = State.avatars.get(conn.peer);
            if (av) { Engine.scene.remove(av); State.avatars.delete(conn.peer); }
            document.getElementById('stats-peers').innerText = State.connections.size;
        });
    },

    handleRemotePos(id, data) {
        if (!State.avatars.has(id)) {
            const name = id.replace(CONFIG.APP_PREFIX, "");
            // Utiliser la couleur stock√©e ou g√©n√©rer une couleur par d√©faut
            const color = State.playerColors.get(id) || this.getHashColor(name);
            const av = Engine.createAvatar(color, name);
            State.avatars.set(id, av);
            Engine.scene.add(av);
        }
        const av = State.avatars.get(id);
        av.position.lerp(new THREE.Vector3(data.p.x, data.p.y, data.p.z), 0.2);
        av.rotation.y = data.r;
    },

    gossip() {
        // Syst√®me de d√©couverte am√©lior√© :
        // 1. Essayer de se connecter aux n≈ìuds pr√©d√©finis
        // 2. Propager la liste des pairs connus
        
        CONFIG.DISCOVERY_NODES.forEach(n => {
            const id = CONFIG.APP_PREFIX + n;
            if (n !== State.username && !State.connections.has(id)) {
                try {
                    const conn = State.peer.connect(id, { reliable: true });
                    if (conn) {
                        this.bindEvents(conn);
                    }
                } catch (e) {
                    // N≈ìud non disponible, silencieux
                }
            }
        });
        
        // Propager la liste des pairs connus aux pairs connect√©s
        // Cela permet la d√©couverte transitive : A conna√Æt B, B conna√Æt C, donc A d√©couvre C
        if (State.connections.size > 0) {
            const knownPeers = Array.from(State.connections.keys());
            this.broadcast({ 
                type: 'peer_discovery', 
                peers: knownPeers,
                origin: CONFIG.APP_PREFIX + State.username
            });
        }
    },
    
    // D√©couvrir de nouveaux pairs via un pair existant
    discoverPeer(peerId) {
        if (peerId === CONFIG.APP_PREFIX + State.username) return; // C'est moi
        if (State.connections.has(peerId)) return; // D√©j√† connect√©
        
        try {
            const conn = State.peer.connect(peerId, { reliable: true });
            if (conn) {
                this.log(`üîç D√©couverte: ${peerId.replace(CONFIG.APP_PREFIX, "")}`);
                this.bindEvents(conn);
            }
        } catch (e) {
            // √âchec silencieux
        }
    },

    getHashColor(str) {
        // G√©n√©rer un hash unique pour chaque string
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = str.charCodeAt(i) + ((hash << 5) - hash);
        }
        
        // Palette de couleurs vives et distinctes
        const colors = [
            0xFF6B6B, // Rouge corail
            0x4ECDC4, // Turquoise
            0xFFE66D, // Jaune dor√©
            0x95E1D3, // Vert menthe
            0xF38181, // Rose saumon
            0xAA96DA, // Violet pastel
            0xFCBF49, // Orange vif
            0x06FFA5, // Vert n√©on
            0xFF5E78, // Rose vif
            0x5B8DEF, // Bleu ciel
            0xFFAA00, // Orange ambre
            0x00D9FF, // Cyan √©lectrique
            0xFF6EC7, // Magenta
            0x7FFF00, // Vert chartreuse
            0xFF4757, // Rouge cerise
            0x48DBB4, // Vert √©meraude
            0xF7B731, // Jaune moutarde
            0x5F27CD, // Violet profond
            0x00D2D3, // Cyan profond
            0xFF9FF3  // Rose bonbon
        ];
        
        // S√©lectionner une couleur bas√©e sur le hash
        const index = Math.abs(hash) % colors.length;
        return colors[index];
    }
};

// UI Listeners
document.getElementById('btn-join').onclick = () => {
    const u = document.getElementById('username').value.trim();
    const p = document.getElementById('password').value;
    if (!u) return;
    
    if (u === 'admin' && p === 'root') State.isArchitect = true;
    
    document.getElementById('login-screen').classList.add('hidden');
    Network.init(u);
    Engine.renderer.domElement.requestPointerLock();
    // Initialiser l'UI du crosshair
    setTimeout(() => Network.updateLockUI(), 100);
};

Engine.init();
</script>
</body>
</html>