<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSV CORE - v0.9.7 (Mesh Authority)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #020617; font-family: ui-sans-serif, system-ui; color: white; }
        canvas { display: block; }
        #ui-root { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .interactive { pointer-events: auto; }
        #crosshair { 
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; 
            background: rgba(255,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%); 
        }
        .glass { background: rgba(15, 23, 42, 0.85); backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.1); }
        #lock-prompt {
            position: absolute; top: 6px; right: 280px;
            display: none;
        }
    </style>
</head>
<body>

<div id="ui-root">
    <!-- Login Screen -->
    <div id="login-screen" class="interactive absolute inset-0 bg-slate-950 flex items-center justify-center z-50">
        <div class="glass p-8 rounded-2xl w-96 shadow-2xl">
            <h1 class="text-3xl font-black text-blue-500 mb-2 text-center italic tracking-tighter">SSV.NETWORK</h1>
            <p class="text-slate-500 text-[10px] mb-8 text-center uppercase tracking-[0.2em]">Maillage Spatial Distribu√©</p>
            
            <div class="space-y-4">
                <div>
                    <label class="text-[10px] text-slate-400 uppercase font-bold ml-1">Identifiant N≈ìud</label>
                    <input id="username" type="text" placeholder="ex: node_alpha" 
                        class="w-full p-3 bg-slate-800/50 text-white rounded-lg border border-slate-700 focus:border-blue-500 outline-none transition-all">
                </div>
                <div id="admin-fields" class="hidden">
                    <label class="text-[10px] text-red-400 uppercase font-bold ml-1">Cl√© G√©sine (Root)</label>
                    <input id="password" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" 
                        class="w-full p-3 bg-red-900/10 text-white rounded-lg border border-red-900/30 focus:border-red-500 outline-none">
                </div>
                <button id="btn-join" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 rounded-lg shadow-lg shadow-blue-900/20 transition-all uppercase text-sm tracking-widest">
                    Initialiser la Connexion
                </button>
                <p class="text-[9px] text-slate-500 text-center cursor-pointer hover:text-white" onclick="document.getElementById('admin-fields').classList.toggle('hidden')">
                    Acc√®s Super Architecte ?
                </p>
            </div>
        </div>
    </div>

    <!-- HUD / Dashboard -->
    <div id="hud" class="hidden absolute top-6 left-6 pointer-events-none">
        <div class="glass p-4 rounded-xl min-w-[220px] space-y-3">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-2">
                    <div id="status-dot" class="w-2 h-2 rounded-full bg-red-500 animate-pulse"></div>
                    <span id="user-display" class="font-bold text-xs uppercase tracking-tight">N≈ìud inconnu</span>
                </div>
                <span id="role-tag" class="text-[9px] px-2 py-0.5 rounded bg-slate-800 text-slate-400 uppercase font-bold">Observer</span>
            </div>
            
            <div class="grid grid-cols-2 gap-2 pt-2 border-t border-white/5">
                <div class="flex flex-col">
                    <span class="text-[9px] text-slate-500 uppercase">Pairs Actifs</span>
                    <span id="stats-peers" class="text-blue-400 font-mono font-bold">0</span>
                </div>
                <div class="flex flex-col">
                    <span class="text-[9px] text-slate-500 uppercase">√âtat Monde</span>
                    <span id="stats-entities" class="text-green-400 font-mono font-bold">0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Control Room (Super Architecte Only) -->
    <div id="control-room" class="hidden interactive absolute top-6 right-6 w-64">
        <div class="glass p-4 rounded-xl space-y-4 border-red-500/20">
            <h2 class="text-red-500 text-[10px] font-black uppercase tracking-widest border-b border-red-500/10 pb-2">Control Room</h2>
            
            <div class="space-y-2">
                <label class="text-[10px] text-slate-400">Gravit√© Universelle</label>
                <input type="range" id="slider-gravity" min="0" max="20" value="9" class="w-full accent-red-500">
            </div>

            <button id="btn-force-sync" class="w-full bg-red-950/50 hover:bg-red-900 border border-red-800 text-red-400 text-[10px] font-bold py-2 rounded uppercase">
                Forcer Synchronisation
            </button>
            
            <div id="mesh-log" class="h-32 overflow-y-auto text-[9px] font-mono text-slate-500 bg-black/30 p-2 rounded border border-white/5">
                > Initialisation kernel...
            </div>
        </div>
    </div>

    <div id="lock-prompt" class="glass p-3 rounded-xl border-blue-500/30" style="display: none;">
        <p class="text-blue-400 font-bold uppercase tracking-widest text-[10px]">Mode Observer</p>
        <p class="text-slate-400 text-[9px]">Cliquez pour contr√¥ler</p>
    </div>
    
    <!-- Chat System -->
    <div id="chat-container" class="hidden interactive absolute bottom-6 left-6 w-96">
        <div class="glass p-3 rounded-xl space-y-2">
            <div id="chat-messages" class="h-40 overflow-y-auto text-[10px] font-mono text-slate-300 bg-black/30 p-2 rounded border border-white/5 space-y-1">
                <div class="text-slate-500 italic">Appuyez sur Entr√©e pour chatter...</div>
            </div>
            <div id="chat-input-container" class="hidden">
                <input id="chat-input" type="text" placeholder="Message..." maxlength="100"
                    class="w-full p-2 bg-slate-800/50 text-white text-[11px] rounded border border-slate-700 focus:border-blue-500 outline-none">
            </div>
        </div>
    </div>
    
    <!-- Inventory Hotbar -->
    <div id="hotbar" class="hidden absolute bottom-6 left-1/2 transform -translate-x-1/2 flex gap-2">
        <!-- Generated dynamically -->
    </div>
    
    <div id="crosshair"></div>
</div>

<script>
/**
 * SSV CORE v0.9.7 - ENGINE
 * Impl√©mentation du Manifeste : Quorum, Recettes JSON et Autorit√©.
 */

const CONFIG = {
    APP_PREFIX: "SSV-MESH-X97-",
    DISCOVERY_NODES: ['admin', 'node0', 'node1', 'node2', 'node3', 'node4', 'node5'],
    GRID_SIZE: 1000,
    CHUNK_SIZE: 16,
    BROADCAST_MS: 45,
    // Utilise l'origine actuelle pour supporter les codespaces et environnements distants
    BACKUP_SERVER: window.location.origin + '/api/backup',
    AUTOSAVE_INTERVAL: 30000, // 30 secondes
    TERRAIN_SIZE: 32,  // Taille du terrain g√©n√©r√© (32x32)
    TERRAIN_HEIGHT: 8  // Hauteur maximale du terrain
};

// G√©n√©rateur de bruit simplex simplifi√© pour terrain proc√©dural
const SimplexNoise = {
    grad3: [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]],
    p: [],
    perm: [],
    
    seed(seed) {
        // Initialiser avec une graine
        if (seed === undefined) seed = Math.random();
        const random = (function(s) {
            let state = s;
            return function() {
                state = (state * 9301 + 49297) % 233280;
                return state / 233280;
            };
        })(seed * 100000);
        
        for (let i = 0; i < 256; i++) this.p[i] = Math.floor(random() * 256);
        for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];
    },
    
    dot(g, x, y) {
        return g[0] * x + g[1] * y;
    },
    
    noise2D(xin, yin) {
        if (!this.perm.length) this.seed();
        
        const F2 = 0.5 * (Math.sqrt(3) - 1);
        const G2 = (3 - Math.sqrt(3)) / 6;
        
        const s = (xin + yin) * F2;
        const i = Math.floor(xin + s);
        const j = Math.floor(yin + s);
        
        const t = (i + j) * G2;
        const X0 = i - t;
        const Y0 = j - t;
        const x0 = xin - X0;
        const y0 = yin - Y0;
        
        const i1 = x0 > y0 ? 1 : 0;
        const j1 = x0 > y0 ? 0 : 1;
        
        const x1 = x0 - i1 + G2;
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1 + 2 * G2;
        const y2 = y0 - 1 + 2 * G2;
        
        const ii = i & 255;
        const jj = j & 255;
        const gi0 = this.perm[ii + this.perm[jj]] % 12;
        const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
        const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
        
        let t0 = 0.5 - x0 * x0 - y0 * y0;
        let n0 = t0 < 0 ? 0 : Math.pow(t0, 4) * this.dot(this.grad3[gi0], x0, y0);
        
        let t1 = 0.5 - x1 * x1 - y1 * y1;
        let n1 = t1 < 0 ? 0 : Math.pow(t1, 4) * this.dot(this.grad3[gi1], x1, y1);
        
        let t2 = 0.5 - x2 * x2 - y2 * y2;
        let n2 = t2 < 0 ? 0 : Math.pow(t2, 4) * this.dot(this.grad3[gi2], x2, y2);
        
        return 70 * (n0 + n1 + n2);
    }
};

const Persistence = {
    // ===== DONN√âES PERSONNELLES DU JOUEUR =====
    
    // G√©n√©rer la cl√© de stockage unique pour un joueur
    getPlayerKey(username) {
        return `ssv_player_${username || State.username}`;
    },

    // Sauvegarder les donn√©es personnelles du joueur
    savePlayer() {
        try {
            if (!State.username) return null;
            
            const playerData = {
                username: State.username,
                color: State.myColor,
                lastPosition: Engine.player ? {
                    x: Engine.player.position.x,
                    y: Engine.player.position.y,
                    z: Engine.player.position.z
                } : { x: 0, y: 0, z: 0 },
                lastSeen: Date.now()
            };
            // Cl√© unique par joueur : ssv_player_node0, ssv_player_node1, etc.
            const key = this.getPlayerKey();
            localStorage.setItem(key, JSON.stringify(playerData));
            console.log(`üë§ Joueur sauvegard√©: ${playerData.username} (${key})`);
            return playerData;
        } catch (e) {
            console.error('‚ùå Erreur sauvegarde joueur:', e);
            return null;
        }
    },

    // Charger les donn√©es personnelles du joueur (par username)
    loadPlayer(username) {
        try {
            const key = this.getPlayerKey(username);
            const data = localStorage.getItem(key);
            if (data) {
                const parsed = JSON.parse(data);
                console.log(`üë§ Joueur charg√©: ${parsed.username} (${key})`);
                return parsed;
            }
        } catch (e) {
            console.error('‚ùå Erreur chargement joueur:', e);
        }
        return null;
    },

    // ===== DONN√âES DU MONDE (LOCAL) =====
    
    // Sauvegarder le monde dans localStorage
    saveWorldLocal() {
        try {
            const worldData = Array.from(State.worldRegistry.values()).map(v => v.recipe);
            const data = {
                version: "0.9.7",
                world: worldData,
                timestamp: Date.now(),
                author: State.username,
                playerColors: Array.from(State.playerColors.entries()),
                laws: {
                    gravity: State.gravity
                }
            };
            localStorage.setItem('ssv_world', JSON.stringify(data));
            console.log(`üíæ Monde local: ${worldData.length} entit√©s sauvegard√©es`);
            return data;
        } catch (e) {
            console.error('‚ùå Erreur sauvegarde monde local:', e);
            return null;
        }
    },

    // Charger le monde depuis localStorage
    loadWorldLocal() {
        try {
            const data = localStorage.getItem('ssv_world');
            if (data) {
                const parsed = JSON.parse(data);
                console.log(`üì¶ Monde local: ${parsed.world.length} entit√©s charg√©es`);
                return parsed;
            }
        } catch (e) {
            console.error('‚ùå Erreur chargement monde local:', e);
        }
        return null;
    },

    // ===== BACKUP SERVEUR (GLOBAL) =====
    
    // Construire les donn√©es de spawn de tous les joueurs connus
    buildPlayerSpawns() {
        const spawns = {};
        
        // Ma propre position
        if (Engine.player) {
            spawns[State.username] = {
                x: Engine.player.position.x,
                y: Engine.player.position.y,
                z: Engine.player.position.z,
                color: State.myColor,
                lastSeen: Date.now()
            };
        }
        
        // Positions des autres joueurs (avatars visibles)
        State.avatars.forEach((avatar, peerId) => {
            const name = peerId.replace(CONFIG.APP_PREFIX, "");
            spawns[name] = {
                x: avatar.position.x,
                y: avatar.position.y,
                z: avatar.position.z,
                color: State.playerColors.get(peerId) || 0xffffff,
                lastSeen: Date.now()
            };
        });
        
        return spawns;
    },

    // Sauvegarder sur le serveur (backup global)
    async saveServer(worldData) {
        try {
            const backupData = {
                version: "0.9.7",
                savedAt: new Date().toISOString(),
                author: State.username,
                
                // √âtat du monde
                world: worldData.world || [],
                
                // Positions de spawn des joueurs (pas live, mais derni√®re position connue)
                playerSpawns: this.buildPlayerSpawns(),
                
                // Couleurs des joueurs
                playerColors: Array.from(State.playerColors.entries()),
                
                // Lois du monde
                laws: {
                    gravity: State.gravity
                }
            };

            const response = await fetch(CONFIG.BACKUP_SERVER, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(backupData)
            });
            
            if (response.ok) {
                const playerCount = Object.keys(backupData.playerSpawns).length;
                console.log(`‚òÅÔ∏è  Backup serveur: ${backupData.world.length} entit√©s, ${playerCount} joueurs`);
            }
        } catch (e) {
            console.warn('‚ö†Ô∏è  Backup serveur √©chou√© (normal si offline):', e.message);
        }
    },

    // Charger depuis le serveur (fallback)
    async loadServer() {
        try {
            const response = await fetch(CONFIG.BACKUP_SERVER);
            if (response.ok) {
                const data = await response.json();
                if (data.world && data.world.length > 0) {
                    console.log(`‚òÅÔ∏è  Serveur: ${data.world.length} entit√©s, ${Object.keys(data.playerSpawns || {}).length} spawns`);
                    return data;
                }
            }
        } catch (e) {
            console.warn('‚ö†Ô∏è  Serveur backup inaccessible (normal si offline):', e.message);
        }
        return null;
    },

    // ===== STRAT√âGIES DE CHARGEMENT =====
    
    // R√©conciliation des donn√©es (timestamp le plus r√©cent gagne)
    reconcile(localData, serverData) {
        if (!localData && !serverData) return null;
        if (!localData) return serverData;
        if (!serverData) return localData;
        
        // Le plus r√©cent gagne pour la base
        const baseData = (localData.timestamp || 0) > (serverData.timestamp || 0) ? localData : serverData;
        
        // Fusionner les entit√©s du monde (plus r√©cent par entit√©)
        const mergedWorld = new Map();
        
        [localData, serverData].forEach(source => {
            if (source && source.world) {
                source.world.forEach(entity => {
                    const existing = mergedWorld.get(entity.id);
                    if (!existing || (entity.ts || 0) > (existing.ts || 0)) {
                        mergedWorld.set(entity.id, entity);
                    }
                });
            }
        });
        
        return {
            ...baseData,
            world: Array.from(mergedWorld.values()),
            timestamp: Date.now()
        };
    },

    // Charger le monde (strat√©gie intelligente)
    async loadWorld() {
        // 1. Charger les deux sources
        const localData = this.loadWorldLocal();
        let serverData = null;
        
        // 2. Essayer le serveur si local vide ou pour r√©conciliation
        if (!localData || !localData.world || localData.world.length === 0) {
            console.log('üì• Local vide, tentative serveur...');
            serverData = await this.loadServer();
        }
        
        // 3. R√©concilier si n√©cessaire
        const data = this.reconcile(localData, serverData);
        
        // 4. Appliquer les donn√©es
        if (data && data.world) {
            data.world.forEach(recipe => Network.commitToWorld(recipe));
            
            // Restaurer les couleurs
            if (data.playerColors) {
                data.playerColors.forEach(([key, value]) => {
                    State.playerColors.set(key, value);
                });
            }
            
            // Restaurer les lois
            if (data.laws) {
                State.gravity = data.laws.gravity || 9.81;
            }
            
            console.log(`‚úÖ Monde charg√©: ${data.world.length} entit√©s`);
            return data;
        }
        
        console.log('üÜï Nouveau monde (aucune sauvegarde trouv√©e)');
        return null;
    },

    // ===== ACTIONS DE SAUVEGARDE =====
    
    // Sauvegarde rapide (locale uniquement)
    saveQuick() {
        this.savePlayer();
        return this.saveWorldLocal();
    },

    // Sauvegarde compl√®te (local + serveur si autoris√©)
    async saveFull() {
        this.savePlayer();
        const worldData = this.saveWorldLocal();
        
        // Backup serveur si admin OU si dernier joueur
        const shouldBackupServer = State.isArchitect || this.isLastPlayer();
        
        if (worldData && shouldBackupServer) {
            await this.saveServer(worldData);
        }
        
        return worldData;
    },

    // V√©rifier si on est le dernier joueur (pour backup d'urgence)
    isLastPlayer() {
        return State.connections.size === 0 && State.isInitialized;
    },

    // ===== LEGACY COMPATIBILITY =====
    
    // Anciennes m√©thodes pour compatibilit√©
    saveLocal() { return this.saveQuick(); },
    loadLocal() { return this.loadWorldLocal(); },
    async load() { return this.loadWorld(); },
    async save() { return this.saveFull(); }
};

/**
 * SaveTrigger - Syst√®me de sauvegarde intelligent
 * G√®re quand et comment sauvegarder bas√© sur plusieurs crit√®res
 */
const SaveTrigger = {
    // Configuration des seuils
    config: {
        // Distance
        distanceThreshold: 5,          // Sauvegarder tous les 5 m√®tres parcourus
        
        // Temps
        timeIntervalIdle: 60000,       // 60s si inactif
        timeIntervalActive: 30000,     // 30s si actif
        
        // Actions (priorit√©s)
        actionPriority: {
            build: 'immediate',         // Construction = sauvegarde imm√©diate
            destroy: 'immediate',       // Destruction = sauvegarde imm√©diate
            inventory: 'deferred',      // Inventaire = sauvegarde diff√©r√©e (batch)
            move: 'threshold',          // Mouvement = sauvegarde par seuil de distance
            idle: 'interval'            // Inactif = sauvegarde par intervalle
        },
        
        // Anti-spam
        minSaveInterval: 2000,          // Minimum 2s entre sauvegardes
        batchDelay: 5000                // D√©lai pour actions "deferred" (5s)
    },
    
    // √âtat du tracker
    state: {
        lastSaveTime: 0,
        lastPosition: { x: 0, y: 0, z: 0 },
        distanceSinceLastSave: 0,
        pendingActions: [],
        batchTimeout: null,
        isActive: false,
        actionCount: 0
    },
    
    // Initialiser le syst√®me
    init() {
        console.log('‚è±Ô∏è SaveTrigger initialis√©');
        this.state.lastSaveTime = Date.now();
        
        // Timer adaptatif (v√©rifie toutes les 5 secondes)
        setInterval(() => this.checkTimeTrigger(), 5000);
    },
    
    // Mettre √† jour la position et v√©rifier le seuil de distance
    updatePosition(newPos) {
        if (!this.state.lastPosition) {
            this.state.lastPosition = { ...newPos };
            return;
        }
        
        // Calculer la distance parcourue
        const dx = newPos.x - this.state.lastPosition.x;
        const dy = newPos.y - this.state.lastPosition.y;
        const dz = newPos.z - this.state.lastPosition.z;
        const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
        
        this.state.distanceSinceLastSave += distance;
        this.state.lastPosition = { ...newPos };
        this.state.isActive = distance > 0.01;
        
        // Seuil de distance atteint ?
        if (this.state.distanceSinceLastSave >= this.config.distanceThreshold) {
            this.triggerSave('distance', `${this.state.distanceSinceLastSave.toFixed(1)}m parcourus`);
            this.state.distanceSinceLastSave = 0;
        }
    },
    
    // Enregistrer une action
    recordAction(actionType, data = {}) {
        const priority = this.config.actionPriority[actionType] || 'deferred';
        this.state.actionCount++;
        
        switch (priority) {
            case 'immediate':
                // Sauvegarde imm√©diate (construction, destruction)
                this.triggerSave('action', `Action: ${actionType}`);
                break;
                
            case 'deferred':
                // Accumuler et sauvegarder en batch
                this.state.pendingActions.push({ type: actionType, data, time: Date.now() });
                this.scheduleBatchSave();
                break;
                
            case 'threshold':
                // G√©r√© par updatePosition()
                break;
                
            case 'interval':
                // G√©r√© par checkTimeTrigger()
                break;
        }
    },
    
    // Programmer une sauvegarde batch (pour actions diff√©r√©es)
    scheduleBatchSave() {
        if (this.state.batchTimeout) return; // D√©j√† programm√©
        
        this.state.batchTimeout = setTimeout(() => {
            const count = this.state.pendingActions.length;
            if (count > 0) {
                this.triggerSave('batch', `${count} actions en attente`);
                this.state.pendingActions = [];
            }
            this.state.batchTimeout = null;
        }, this.config.batchDelay);
    },
    
    // V√©rifier le trigger temporel
    checkTimeTrigger() {
        const now = Date.now();
        const elapsed = now - this.state.lastSaveTime;
        const interval = this.state.isActive 
            ? this.config.timeIntervalActive 
            : this.config.timeIntervalIdle;
        
        if (elapsed >= interval) {
            const mode = this.state.isActive ? 'actif' : 'inactif';
            this.triggerSave('time', `Intervalle ${mode} (${Math.round(elapsed/1000)}s)`);
        }
    },
    
    // D√©clencher une sauvegarde
    triggerSave(reason, details = '') {
        const now = Date.now();
        
        // Anti-spam : respecter l'intervalle minimum
        if (now - this.state.lastSaveTime < this.config.minSaveInterval) {
            console.log(`‚è≥ Sauvegarde ignor√©e (anti-spam): ${reason}`);
            return false;
        }
        
        this.state.lastSaveTime = now;
        
        // Log d√©taill√©
        console.log(`üíæ Sauvegarde [${reason}]: ${details}`);
        
        // Ex√©cuter la sauvegarde appropri√©e
        switch (reason) {
            case 'action':
                // Actions critiques = sauvegarde compl√®te
                Persistence.saveFull();
                break;
                
            case 'distance':
            case 'time':
            case 'batch':
                // Autres = sauvegarde rapide
                Persistence.saveQuick();
                break;
                
            default:
                Persistence.saveQuick();
        }
        
        return true;
    },
    
    // Forcer une sauvegarde imm√©diate (fermeture, urgence)
    forceImmediate(reason = 'forced') {
        console.log(`üö® Sauvegarde forc√©e: ${reason}`);
        this.state.lastSaveTime = 0; // Bypass anti-spam
        Persistence.saveQuick();
    },
    
    // Obtenir les statistiques
    getStats() {
        return {
            lastSave: new Date(this.state.lastSaveTime).toLocaleTimeString(),
            distanceSinceLastSave: this.state.distanceSinceLastSave.toFixed(1) + 'm',
            pendingActions: this.state.pendingActions.length,
            totalActions: this.state.actionCount,
            isActive: this.state.isActive
        };
    }
};

// Types de blocs disponibles
const BLOCK_TYPES = {
    stone: { color: 0x808080, name: 'Pierre' },
    dirt: { color: 0x8B4513, name: 'Terre' },
    wood: { color: 0xDEB887, name: 'Bois' },
    grass: { color: 0x228B22, name: 'Herbe' },
    sand: { color: 0xF4A460, name: 'Sable' },
    snow: { color: 0xFFFAFA, name: 'Neige' },
    water: { color: 0x1E90FF, name: 'Eau' },
    obsidian: { color: 0x1C1C1C, name: 'Obsidienne' },
    gold: { color: 0xFFD700, name: 'Or' }
};

const State = {
    peer: null,
    username: "",
    isArchitect: false,
    myColor: null, // Ma couleur personnelle
    playerColors: new Map(), // peerId -> couleur
    connections: new Map(),
    avatars: new Map(),
    worldRegistry: new Map(), // Registre des "Recettes" (ID -> Data)
    pendingActions: new Map(), // Actions en attente de validation (quorum)
    gravity: 9.81,
    velocityY: 0,
    isGrounded: true,
    isInitialized: false,
    isTabActive: true,
    chatActive: false,
    lamportClock: 0,  // Horloge de Lamport pour ordre logique
    // Inventaire du joueur (9 slots)
    inventory: [
        'stone', 'dirt', 'wood', 'grass', 'sand', 
        'snow', 'water', 'obsidian', 'gold'
    ],
    selectedSlot: 0  // Slot actuellement s√©lectionn√© (0-8)
};

const Engine = {
    scene: null, camera: null, renderer: null, worldGroup: null, player: null,
    cameraData: {
        yaw: 0, pitch: -0.3, distance: 8, targetDistance: 8, heightOffset: 1.5,
        minPitch: -1.4, maxPitch: 0.2
    },

    init() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x020617);
        this.scene.fog = new THREE.FogExp2(0x020617, 0.015);
        
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        document.body.appendChild(this.renderer.domElement);

        // Lights
        this.scene.add(new THREE.AmbientLight(0x404040, 0.6));
        const sun = new THREE.DirectionalLight(0xffffff, 1.0);
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        this.scene.add(sun);

        // Ground Grid
        const grid = new THREE.GridHelper(CONFIG.GRID_SIZE, 100, 0x1e293b, 0x0f172a);
        this.scene.add(grid);

        this.worldGroup = new THREE.Group();
        this.scene.add(this.worldGroup);

        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });

        this.animate();
    },

    createAvatar(color, name = "Pair") {
        const group = new THREE.Group();
        // Body
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.4), new THREE.MeshStandardMaterial({ color, roughness: 0.3 }));
        body.position.y = 0.6;
        body.castShadow = true;
        group.add(body);
        
        // Head
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshStandardMaterial({ color: 0xffffff }));
        head.position.y = 1.45;
        group.add(head);

        // Nametag (Canvas-based simple sprite)
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 256; canvas.height = 64;
        ctx.fillStyle = 'white'; ctx.font = 'bold 32px Inter, sans-serif';
        ctx.textAlign = 'center'; ctx.fillText(name, 128, 48);
        const tex = new THREE.CanvasTexture(canvas);
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex }));
        sprite.position.y = 2.2;
        sprite.scale.set(1.5, 0.375, 1);
        group.add(sprite);

        return group;
    },

    animate() {
        requestAnimationFrame(() => this.animate());
        // Le jeu continue m√™me si pointer lock rel√¢ch√©, pause uniquement si changement d'onglet
        if (!State.isInitialized || !State.isTabActive) return;
        
        Network.processPhysics();
        
        if (this.player) {
            this.cameraData.distance += (this.cameraData.targetDistance - this.cameraData.distance) * 0.1;
            const offsetX = this.cameraData.distance * Math.sin(this.cameraData.yaw) * Math.cos(this.cameraData.pitch);
            const offsetZ = this.cameraData.distance * Math.cos(this.cameraData.yaw) * Math.cos(this.cameraData.pitch);
            const offsetY = -this.cameraData.distance * Math.sin(this.cameraData.pitch);
            
            this.camera.position.lerp(new THREE.Vector3(
                this.player.position.x + offsetX,
                this.player.position.y + this.cameraData.heightOffset + offsetY,
                this.player.position.z + offsetZ
            ), 0.15);
            this.camera.lookAt(this.player.position.clone().add(new THREE.Vector3(0, 1.2, 0)));
        }
        this.renderer.render(this.scene, this.camera);
    }
};

const Network = {
    keys: {},
    async init(username) {
        State.username = username.toLowerCase();
        State.isInitialized = true;
        
        // G√©n√©rer ma couleur unique
        State.myColor = this.getHashColor(State.username);
        State.playerColors.set(CONFIG.APP_PREFIX + State.username, State.myColor);
        
        document.getElementById('user-display').innerText = State.username;
        if (State.isArchitect) {
            document.getElementById('role-tag').innerText = "Root";
            document.getElementById('role-tag').classList.replace('bg-slate-800', 'bg-red-600');
            document.getElementById('role-tag').classList.replace('text-slate-400', 'text-white');
            document.getElementById('control-room').classList.remove('hidden');
        }

        Engine.player = Engine.createAvatar(State.myColor, State.username);
        Engine.scene.add(Engine.player);

        // Charger les donn√©es du joueur (position de spawn) - avec le username actuel
        const playerData = Persistence.loadPlayer(State.username);
        if (playerData && playerData.lastPosition) {
            Engine.player.position.set(
                playerData.lastPosition.x,
                playerData.lastPosition.y,
                playerData.lastPosition.z
            );
            console.log(`üìç Position restaur√©e pour ${State.username}: (${playerData.lastPosition.x.toFixed(1)}, ${playerData.lastPosition.y.toFixed(1)}, ${playerData.lastPosition.z.toFixed(1)})`);
        } else {
            console.log(`üÜï Nouveau joueur ${State.username}, position par d√©faut`);
            // G√©n√©rer le terrain proc√©dural pour nouveau joueur
            this.generateProceduralTerrain();
        }

        // Charger le monde sauvegard√©
        const worldData = await Persistence.loadWorld();
        
        // Si on a des spawns du serveur, proposer de s'y t√©l√©porter
        if (worldData && worldData.playerSpawns && worldData.playerSpawns[State.username]) {
            const spawn = worldData.playerSpawns[State.username];
            console.log(`üéØ Spawn serveur disponible pour ${State.username}`);
        }

        State.peer = new Peer(CONFIG.APP_PREFIX + State.username);
        State.peer.on('open', (id) => {
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('status-dot').classList.replace('bg-red-500', 'bg-green-500');
            this.log(`Node OK : ${id}`);
            this.gossip();
            setInterval(() => this.gossip(), 5000);
            
            // Initialiser le syst√®me de sauvegarde intelligent
            SaveTrigger.init();
            
            // Afficher le chat
            document.getElementById('chat-container').classList.remove('hidden');
        });

        State.peer.on('connection', (conn) => this.bindEvents(conn));
        
        // G√©rer l'√©v√©nement de kick (identifiant dupliqu√©)
        State.peer.on('error', (err) => {
            if (err.type === 'peer-unavailable') {
                // Peer non disponible, normal
            } else {
                console.error('Erreur PeerJS:', err);
            }
        });

        // Input Bindings
        window.addEventListener('keydown', (e) => {
            // Touche Entr√©e = activer/d√©sactiver chat
            if (e.code === 'Enter') {
                this.toggleChat();
                e.preventDefault();
                return;
            }
            
            // Si chat actif, ne pas traiter les touches de jeu
            if (State.chatActive) return;
            
            // S√©lection de slot d'inventaire (touches 1-9)
            if (e.key >= '1' && e.key <= '9') {
                State.selectedSlot = parseInt(e.key) - 1;
                this.updateHotbar();
            }
            
            this.keys[e.code] = true;
        });
        window.addEventListener('keyup', (e) => {
            // Si chat actif, ne pas traiter les touches de jeu
            if (State.chatActive) return;
            
            this.keys[e.code] = false;
        });
        
        // Pause uniquement si on change d'onglet (pas si souris quitte la fen√™tre)
        document.addEventListener('visibilitychange', () => {
            State.isTabActive = !document.hidden;
            if (document.hidden) {
                this.keys = {}; // R√©initialiser les touches si on quitte l'onglet
                SaveTrigger.forceImmediate('tab_hidden'); // Sauvegarde forc√©e
            }
        });
        
        // Sauvegarde avant fermeture de la page
        window.addEventListener('beforeunload', () => {
            SaveTrigger.forceImmediate('page_unload'); // Sauvegarde forc√©e
        });
        
        // G√©rer le changement de pointer lock (√âchap lib√®re la souris)
        document.addEventListener('pointerlockchange', () => {
            this.updateLockUI();
            // R√©initialiser les touches quand on lib√®re le contr√¥le
            if (document.pointerLockElement !== Engine.renderer.domElement) {
                this.keys = {};
            }
        });

        window.addEventListener('mousedown', (e) => {
            if (document.pointerLockElement !== Engine.renderer.domElement) {
                Engine.renderer.domElement.requestPointerLock();
                return; 
            }
            // Clic gauche = construction, clic droit = destruction
            if (e.button === 0) {
                this.requestAction('build');
            } else if (e.button === 2) {
                this.requestAction('destroy');
            }
        });
        
        // Emp√™cher le menu contextuel du clic droit
        window.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        window.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === Engine.renderer.domElement) {
                Engine.cameraData.yaw += e.movementX * 0.003;
                Engine.cameraData.pitch = Math.max(
                    Engine.cameraData.minPitch, 
                    Math.min(Engine.cameraData.maxPitch, Engine.cameraData.pitch + e.movementY * 0.003)
                );
            }
        });

        // Admin controls
        document.getElementById('slider-gravity').oninput = (e) => {
            const val = parseFloat(e.target.value) / 10;
            this.broadcast({ type: 'law', key: 'gravity', value: val });
        };
        
        // Initialiser la hotbar (barre d'inventaire)
        this.initHotbar();
    },

    updateLockUI() {
        const prompt = document.getElementById('lock-prompt');
        const crosshair = document.getElementById('crosshair');
        const isLocked = document.pointerLockElement === Engine.renderer.domElement;
        
        // Afficher le prompt et masquer le crosshair seulement si d√©verrouill√©
        prompt.style.display = isLocked ? 'none' : 'block';
        crosshair.style.display = isLocked ? 'block' : 'none';
    },

    log(msg) {
        const log = document.getElementById('mesh-log');
        log.innerHTML += `<div>> ${msg}</div>`;
        log.scrollTop = log.scrollHeight;
    },
    
    // === SYST√àME DE CHAT ===
    
    toggleChat() {
        State.chatActive = !State.chatActive;
        const inputContainer = document.getElementById('chat-input-container');
        const input = document.getElementById('chat-input');
        
        if (State.chatActive) {
            // Activer le chat
            inputContainer.classList.remove('hidden');
            input.focus();
            document.exitPointerLock();
        } else {
            // D√©sactiver le chat
            const message = input.value.trim();
            if (message) {
                this.sendChatMessage(message);
            }
            inputContainer.classList.add('hidden');
            input.value = '';
        }
    },
    
    sendChatMessage(message) {
        if (!message) return;
        
        const chatData = {
            type: 'chat',
            username: State.username,
            message: message,
            color: State.myColor,
            timestamp: Date.now()
        };
        
        // Afficher localement
        this.displayChatMessage(chatData);
        
        // Broadcaster aux pairs
        this.broadcast(chatData);
    },
    
    displayChatMessage(data) {
        const messagesDiv = document.getElementById('chat-messages');
        const messageEl = document.createElement('div');
        
        // Format: [HH:MM] Username: Message
        const time = new Date(data.timestamp).toLocaleTimeString('fr-FR', { 
            hour: '2-digit', 
            minute: '2-digit' 
        });
        
        const colorHex = '#' + data.color.toString(16).padStart(6, '0');
        messageEl.innerHTML = `<span class="text-slate-500">[${time}]</span> <span style="color: ${colorHex}; font-weight: bold;">${data.username}:</span> ${this.escapeHtml(data.message)}`;
        
        messagesDiv.appendChild(messageEl);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
        
        // Limiter √† 50 messages
        while (messagesDiv.children.length > 50) {
            messagesDiv.removeChild(messagesDiv.firstChild);
        }
    },
    
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    },
    
    // === HOTBAR / INVENTAIRE ===
    
    initHotbar() {
        const hotbar = document.getElementById('hotbar');
        hotbar.innerHTML = '';
        
        State.inventory.forEach((blockType, index) => {
            const slot = document.createElement('div');
            const blockInfo = BLOCK_TYPES[blockType];
            const colorHex = '#' + blockInfo.color.toString(16).padStart(6, '0');
            
            slot.className = `interactive w-14 h-14 glass rounded-lg flex flex-col items-center justify-center cursor-pointer transition-all border-2 ${
                index === State.selectedSlot ? 'border-blue-500 shadow-lg shadow-blue-500/50' : 'border-transparent hover:border-white/20'
            }`;
            slot.innerHTML = `
                <div class="w-8 h-8 rounded" style="background-color: ${colorHex};"></div>
                <div class="text-[8px] text-slate-400 mt-1">${index + 1}</div>
            `;
            slot.onclick = () => {
                State.selectedSlot = index;
                this.updateHotbar();
            };
            
            hotbar.appendChild(slot);
        });
        
        hotbar.classList.remove('hidden');
    },
    
    updateHotbar() {
        const hotbar = document.getElementById('hotbar');
        const slots = hotbar.children;
        
        for (let i = 0; i < slots.length; i++) {
            if (i === State.selectedSlot) {
                slots[i].className = 'interactive w-14 h-14 glass rounded-lg flex flex-col items-center justify-center cursor-pointer transition-all border-2 border-blue-500 shadow-lg shadow-blue-500/50';
            } else {
                slots[i].className = 'interactive w-14 h-14 glass rounded-lg flex flex-col items-center justify-center cursor-pointer transition-all border-2 border-transparent hover:border-white/20';
            }
        }
    },
    
    // === HORLOGE DE LAMPORT ===
    
    // Incr√©menter l'horloge lors d'un √©v√©nement local
    tick() {
        State.lamportClock++;
        return State.lamportClock;
    },
    
    // Synchroniser avec une horloge re√ßue
    sync(receivedClock) {
        State.lamportClock = Math.max(State.lamportClock, receivedClock) + 1;
        return State.lamportClock;
    },
    
    // R√©soudre un conflit (timestamp identique)
    resolveConflict(a, b) {
        // Si horloges diff√©rentes, le plus grand gagne
        if (a.lamport !== b.lamport) {
            return a.lamport > b.lamport ? a : b;
        }
        // Si horloges identiques, ordre alphab√©tique du cr√©ateur
        return a.creator > b.creator ? a : b;
    },
    
    // === G√âN√âRATION PROC√âDURALE ===
    
    generateProceduralTerrain() {
        console.log('üåç G√©n√©ration du terrain proc√©dural...');
        SimplexNoise.seed(Math.random());
        
        const size = CONFIG.TERRAIN_SIZE;
        const maxHeight = CONFIG.TERRAIN_HEIGHT;
        const offsetX = -size / 2;
        const offsetZ = -size / 2;
        
        let blockCount = 0;
        
        for (let x = 0; x < size; x++) {
            for (let z = 0; z < size; z++) {
                // G√©n√©rer hauteur avec bruit simplex (plusieurs octaves)
                const scale = 0.08;
                const height1 = SimplexNoise.noise2D(x * scale, z * scale);
                const height2 = SimplexNoise.noise2D(x * scale * 2, z * scale * 2) * 0.5;
                const combinedHeight = (height1 + height2) / 1.5;
                
                // Convertir en hauteur de blocs (0 √† maxHeight)
                const blockHeight = Math.floor(((combinedHeight + 1) / 2) * maxHeight);
                
                // G√©n√©rer colonne de blocs
                for (let y = 0; y <= blockHeight; y++) {
                    let blockType;
                    
                    // S√©lectionner type selon la hauteur
                    if (y === blockHeight && y > 2) {
                        blockType = 'grass';  // Surface
                    } else if (y === blockHeight && y <= 2) {
                        blockType = 'sand';   // Niveau de l'eau
                    } else if (y > blockHeight - 3) {
                        blockType = 'dirt';   // Sous-sol proche
                    } else {
                        blockType = 'stone';  // Roche profonde
                    }
                    
                    // Neige sur les hauteurs
                    if (blockHeight >= maxHeight - 2 && y === blockHeight) {
                        blockType = 'snow';
                    }
                    
                    const recipe = {
                        id: `terrain_${x}_${y}_${z}`,
                        t: 'block',
                        blockType: blockType,
                        p: { x: offsetX + x, y: y, z: offsetZ + z },
                        c: BLOCK_TYPES[blockType].color,
                        creator: 'terrain_gen',
                        lamport: this.tick(),
                        ts: Date.now(),
                        witnesses: []
                    };
                    
                    this.commitToWorld(recipe);
                    blockCount++;
                }
            }
        }
        
        console.log(`‚úÖ Terrain g√©n√©r√©: ${blockCount} blocs cr√©√©s`);
        
        // Positionner le joueur au centre du terrain
        Engine.player.position.set(0, maxHeight + 5, 0);
    },

    // LE QUORUM : On ne construit pas tout de suite, on demande au maillage
    requestAction(type) {
        if (type === 'build') {
            const dir = new THREE.Vector3();
            Engine.camera.getWorldDirection(dir);
            const pos = new THREE.Vector3().copy(Engine.player.position).add(dir.multiplyScalar(4));
            
            // R√©cup√©rer le type de bloc s√©lectionn√© dans l'inventaire
            const blockType = State.inventory[State.selectedSlot];
            const blockColor = State.isArchitect ? 0xef4444 : BLOCK_TYPES[blockType].color;
            
            const recipe = {
                id: `ent_${Math.random().toString(36).substr(2, 9)}`,
                t: 'block',
                blockType: blockType,  // Type de bloc (stone, dirt, etc.)
                p: { x: Math.round(pos.x), y: Math.round(pos.y), z: Math.round(pos.z) },
                c: blockColor,
                creator: State.username,
                lamport: this.tick(),  // Horloge de Lamport au lieu de timestamp
                ts: Date.now(),  // Garder timestamp pour compatibilit√©/debug
                witnesses: []  // Liste des t√©moins
            };

            // Admin bypass le quorum
            if (State.isArchitect) {
                this.log(`‚úÖ Admin: ${recipe.id} [L${recipe.lamport}] - Direct`);
                this.broadcast({ type: 'intent_build', recipe, lamport: recipe.lamport });
                this.commitToWorld(recipe);
                SaveTrigger.recordAction('build', { recipeId: recipe.id });
                return;
            }

            // Si seul, pas besoin de quorum
            if (State.connections.size === 0) {
                this.log(`‚úÖ Solo: ${recipe.id} [L${recipe.lamport}]`);
                this.commitToWorld(recipe);
                SaveTrigger.recordAction('build', { recipeId: recipe.id });
                return;
            }

            // Demander quorum
            this.log(`‚è≥ Quorum: ${recipe.id} [L${recipe.lamport}] - En attente...`);
            State.pendingActions.set(recipe.id, {
                recipe,
                witnesses: [],
                requiredWitnesses: 1,
                timeout: setTimeout(() => {
                    this.checkQuorum(recipe.id);
                }, 500)  // 500ms timeout
            });
            
            // Broadcast demande de validation
            this.broadcast({ 
                type: 'request_witness', 
                recipe, 
                lamport: recipe.lamport,
                requester: State.username
            });
        }
        else if (type === 'destroy') {
            // Raycast pour trouver le bloc vis√©
            const targetBlock = this.raycastBlock();
            if (targetBlock) {
                const lamport = this.tick();
                this.log(`Destruction: ${targetBlock.id} [L${lamport}]`);
                // Broadcast intention de destruction
                this.broadcast({ type: 'intent_destroy', blockId: targetBlock.id, lamport });
                // Optimistic deletion
                this.destroyFromWorld(targetBlock.id);
                
                // üîî D√©clencher sauvegarde (action critique)
                SaveTrigger.recordAction('destroy', { blockId: targetBlock.id });
            }
        }
    },
    
    // Raycast pour trouver le bloc vis√©
    raycastBlock() {
        const raycaster = new THREE.Raycaster();
        const dir = new THREE.Vector3();
        Engine.camera.getWorldDirection(dir);
        raycaster.set(Engine.camera.position, dir);
        
        // Chercher dans les blocs
        const meshes = Array.from(State.worldRegistry.values()).map(v => v.mesh);
        const intersects = raycaster.intersectObjects(meshes);
        
        if (intersects.length > 0) {
            // Trouver l'ID du bloc touch√©
            for (let [id, data] of State.worldRegistry) {
                if (data.mesh === intersects[0].object) {
                    return { id, ...data };
                }
            }
        }
        return null;
    },
    
    // Supprimer un bloc du monde
    destroyFromWorld(blockId) {
        const data = State.worldRegistry.get(blockId);
        if (data) {
            Engine.worldGroup.remove(data.mesh);
            data.mesh.geometry.dispose();
            data.mesh.material.dispose();
            State.worldRegistry.delete(blockId);
            document.getElementById('stats-entities').innerText = State.worldRegistry.size;
        }
    },
    
    // === SYST√àME DE QUORUM ===
    
    // V√©rifier si le quorum est atteint
    checkQuorum(recipeId) {
        const pending = State.pendingActions.get(recipeId);
        if (!pending) return;
        
        const witnesses = pending.witnesses.length;
        const required = pending.requiredWitnesses;
        
        if (witnesses >= required) {
            // Quorum atteint ‚úÖ
            this.log(`‚úÖ Quorum OK: ${recipeId} (${witnesses}/${required} t√©moins)`);
            this.commitToWorld(pending.recipe);
            this.broadcast({ type: 'intent_build', recipe: pending.recipe, lamport: pending.recipe.lamport });
            SaveTrigger.recordAction('build', { recipeId });
        } else {
            // Quorum √©chou√© ‚ùå
            this.log(`‚ùå Quorum KO: ${recipeId} (${witnesses}/${required} t√©moins) - Annul√©`);
        }
        
        // Nettoyer
        clearTimeout(pending.timeout);
        State.pendingActions.delete(recipeId);
    },
    
    // Ajouter un t√©moin √† une action en attente
    addWitness(recipeId, witness) {
        const pending = State.pendingActions.get(recipeId);
        if (!pending) return;
        
        if (!pending.witnesses.includes(witness)) {
            pending.witnesses.push(witness);
            this.log(`üëÅÔ∏è T√©moin: ${witness} pour ${recipeId}`);
            
            // V√©rifier imm√©diatement si quorum atteint
            if (pending.witnesses.length >= pending.requiredWitnesses) {
                this.checkQuorum(recipeId);
            }
        }
    },
    
    // Valider une action d'un pair (devenir t√©moin)
    witnessAction(recipe, requester) {
        // Conditions pour √™tre t√©moin :
        // 1. Pas le cr√©ateur
        // 2. Distance raisonnable (optionnel pour simplifier)
        if (requester === State.username) return;
        
        // Valider automatiquement (version simple)
        this.broadcast({
            type: 'witness_ack',
            recipeId: recipe.id,
            witness: State.username,
            requester: requester
        });
        
        this.log(`üëÅÔ∏è Je t√©moigne pour ${recipe.id} de ${requester}`);
    },

    commitToWorld(recipe) {
        // V√©rifier s'il existe d√©j√†
        if (State.worldRegistry.has(recipe.id)) {
            const existing = State.worldRegistry.get(recipe.id);
            // R√©soudre le conflit avec Lamport
            if (recipe.lamport && existing.recipe.lamport) {
                const winner = this.resolveConflict(recipe, existing.recipe);
                if (winner === existing.recipe) {
                    console.log(`‚öñÔ∏è Conflit r√©solu: ${existing.recipe.creator} garde le bloc`);
                    return; // L'ancien gagne
                }
                // Le nouveau gagne, on supprime l'ancien
                console.log(`‚öñÔ∏è Conflit r√©solu: ${recipe.creator} remplace le bloc`);
                this.destroyFromWorld(recipe.id);
            } else {
                return; // D√©j√† pr√©sent, on ignore
            }
        }
        
        const geo = new THREE.BoxGeometry(1, 1, 1);
        const mat = new THREE.MeshStandardMaterial({ color: recipe.c });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(recipe.p.x, recipe.p.y, recipe.p.z);
        mesh.castShadow = mesh.receiveShadow = true;
        
        Engine.worldGroup.add(mesh);
        State.worldRegistry.set(recipe.id, { mesh, recipe });
        document.getElementById('stats-entities').innerText = State.worldRegistry.size;
    },

    processPhysics() {
        if (!Engine.player) return;
        
        // Vitesse de base et course (Shift)
        const baseSpeed = 0.12;
        const sprintMultiplier = this.keys['ShiftLeft'] || this.keys['ShiftRight'] ? 1.8 : 1;
        const speed = baseSpeed * sprintMultiplier;
        
        const move = new THREE.Vector3();
        if (this.keys['KeyW'] || this.keys['KeyZ']) move.z -= 1;
        if (this.keys['KeyS']) move.z += 1;
        if (this.keys['KeyA'] || this.keys['KeyQ']) move.x -= 1;
        if (this.keys['KeyD']) move.x += 1;

        if (move.length() > 0) {
            move.normalize();
            // Appliquer la rotation de la cam√©ra au vecteur de mouvement
            move.applyAxisAngle(new THREE.Vector3(0, 1, 0), Engine.cameraData.yaw);
            
            // Sauvegarder la position avant mouvement
            const oldPos = Engine.player.position.clone();
            Engine.player.position.add(move.multiplyScalar(speed));
            
            // V√©rifier collision avec les blocs
            if (this.checkBlockCollision()) {
                // Collision d√©tect√©e, annuler le mouvement
                Engine.player.position.copy(oldPos);
            }
            
            // Orienter le personnage dans la direction du mouvement
            Engine.player.rotation.y = Math.atan2(move.x, move.z);
        }
        
        // Saut (Espace)
        if ((this.keys['Space']) && State.isGrounded) {
            State.velocityY = 0.25;
            State.isGrounded = false;
        }
        
        // Gravit√© et physique verticale
        State.velocityY -= State.gravity * 0.002;
        const oldY = Engine.player.position.y;
        Engine.player.position.y += State.velocityY;
        
        // V√©rifier collision verticale
        if (this.checkBlockCollision()) {
            // Collision en tombant/sautant
            Engine.player.position.y = oldY;
            State.velocityY = 0;
            if (oldY > Engine.player.position.y || State.velocityY < 0) {
                State.isGrounded = true;
            }
        }
        
        // Collision avec le sol
        if (Engine.player.position.y <= 0) {
            Engine.player.position.y = 0;
            State.velocityY = 0;
            State.isGrounded = true;
        }

        // üîî Tracker la position pour le syst√®me de sauvegarde
        SaveTrigger.updatePosition({
            x: Engine.player.position.x,
            y: Engine.player.position.y,
            z: Engine.player.position.z
        });

        this.broadcast({ 
            type: 'pos', 
            p: { x: Engine.player.position.x, y: Engine.player.position.y, z: Engine.player.position.z }, 
            r: Engine.player.rotation.y,
            color: State.myColor
        });
    },
    
    // D√©tection de collision AABB (Axis-Aligned Bounding Box)
    checkBlockCollision() {
        if (!Engine.player) return false;
        
        // Hitbox du joueur (cylindre simplifi√© en AABB)
        const playerRadius = 0.3;
        const playerHeight = 1.8;
        const playerBox = {
            minX: Engine.player.position.x - playerRadius,
            maxX: Engine.player.position.x + playerRadius,
            minY: Engine.player.position.y,
            maxY: Engine.player.position.y + playerHeight,
            minZ: Engine.player.position.z - playerRadius,
            maxZ: Engine.player.position.z + playerRadius
        };
        
        // V√©rifier collision avec chaque bloc
        for (let [id, data] of State.worldRegistry) {
            const blockPos = data.recipe.p;
            // Hitbox du bloc (1x1x1)
            const blockBox = {
                minX: blockPos.x - 0.5,
                maxX: blockPos.x + 0.5,
                minY: blockPos.y - 0.5,
                maxY: blockPos.y + 0.5,
                minZ: blockPos.z - 0.5,
                maxZ: blockPos.z + 0.5
            };
            
            // Test AABB
            if (playerBox.maxX > blockBox.minX && playerBox.minX < blockBox.maxX &&
                playerBox.maxY > blockBox.minY && playerBox.minY < blockBox.maxY &&
                playerBox.maxZ > blockBox.minZ && playerBox.minZ < blockBox.maxZ) {
                return true; // Collision d√©tect√©e
            }
        }
        
        return false;
    },

    broadcast(data) {
        State.connections.forEach(conn => { if (conn.open) conn.send(data); });
    },

    bindEvents(conn) {
        conn.on('open', () => {
            State.connections.set(conn.peer, conn);
            document.getElementById('stats-peers').innerText = State.connections.size;
            this.log(`Peer connect√©: ${conn.peer.replace(CONFIG.APP_PREFIX, "")}`);
            
            // V√©rifier les identifiants dupliqu√©s
            const remoteName = conn.peer.replace(CONFIG.APP_PREFIX, "");
            const myName = State.username;
            
            // Si quelqu'un a le m√™me nom que moi, je kick l'ancien (moi)
            if (remoteName === myName) {
                this.log(`‚ö†Ô∏è Identifiant dupliqu√© d√©tect√©: ${remoteName}`);
                // Le nouveau me kick (je suis l'ancien)
                setTimeout(() => {
                    alert(`Un autre joueur s'est connect√© avec votre identifiant "${myName}".\nVous avez √©t√© d√©connect√©.`);
                    location.reload();
                }, 500);
                return;
            }
            
            // Envoyer mon identit√© avec ma couleur
            conn.send({ type: 'identity', username: myName, color: State.myColor });
            
            // Sync initial du monde
            if (State.worldRegistry.size > 0) {
                const worldState = Array.from(State.worldRegistry.values()).map(v => v.recipe);
                conn.send({ type: 'sync_world', data: worldState });
            }
            
            // Partager ma liste de pairs connus (d√©couverte transitive)
            if (State.connections.size > 1) {
                const knownPeers = Array.from(State.connections.keys());
                conn.send({ 
                    type: 'peer_discovery', 
                    peers: knownPeers,
                    origin: CONFIG.APP_PREFIX + State.username
                });
            }
        });
        
        conn.on('data', (data) => {
            // Synchroniser l'horloge de Lamport si pr√©sente
            if (data.lamport !== undefined) {
                this.sync(data.lamport);
            }
            
            switch(data.type) {
                case 'pos': 
                    // Mettre √† jour la couleur si fournie
                    if (data.color) {
                        State.playerColors.set(conn.peer, data.color);
                    }
                    this.handleRemotePos(conn.peer, data); 
                    break;
                case 'intent_build': 
                    this.commitToWorld(data.recipe); 
                    break;
                case 'intent_destroy': 
                    this.destroyFromWorld(data.blockId); 
                    break;
                case 'sync_world': data.data.forEach(r => this.commitToWorld(r)); break;
                case 'chat':
                    // Message de chat re√ßu
                    this.displayChatMessage(data);
                    break;
                case 'identity':
                    // Un pair m'informe de son identit√©
                    // Stocker sa couleur
                    if (data.color) {
                        State.playerColors.set(conn.peer, data.color);
                    }
                    // Si c'est le m√™me que le mien, je suis l'ancien, je me d√©connecte
                    if (data.username === State.username) {
                        this.log(`‚ö†Ô∏è Collision d'identifiant avec ${conn.peer}`);
                        alert(`Un autre joueur utilise l'identifiant "${State.username}".\nVous allez √™tre d√©connect√©.`);
                        setTimeout(() => location.reload(), 1000);
                    }
                    break;
                case 'peer_discovery':
                    // Un pair me partage sa liste de pairs connus
                    if (data.peers && Array.isArray(data.peers)) {
                        data.peers.forEach(peerId => this.discoverPeer(peerId));
                    }
                    break;
                case 'request_witness':
                    // Un pair demande validation pour une action
                    this.witnessAction(data.recipe, data.requester);
                    break;
                case 'witness_ack':
                    // Un pair valide mon action
                    if (data.requester === State.username) {
                        this.addWitness(data.recipeId, data.witness);
                    }
                    break;
                case 'law': 
                    if (conn.peer.includes('admin')) {
                        State[data.key] = data.value;
                        this.log(`Loi modifi√©e: ${data.key} = ${data.value}`);
                    }
                    break;
            }
        });

        conn.on('close', () => {
            State.connections.delete(conn.peer);
            const av = State.avatars.get(conn.peer);
            if (av) { Engine.scene.remove(av); State.avatars.delete(conn.peer); }
            document.getElementById('stats-peers').innerText = State.connections.size;
        });
    },

    handleRemotePos(id, data) {
        if (!State.avatars.has(id)) {
            const name = id.replace(CONFIG.APP_PREFIX, "");
            // Utiliser la couleur stock√©e ou g√©n√©rer une couleur par d√©faut
            const color = State.playerColors.get(id) || this.getHashColor(name);
            const av = Engine.createAvatar(color, name);
            State.avatars.set(id, av);
            Engine.scene.add(av);
        }
        const av = State.avatars.get(id);
        av.position.lerp(new THREE.Vector3(data.p.x, data.p.y, data.p.z), 0.2);
        av.rotation.y = data.r;
    },

    gossip() {
        // Syst√®me de d√©couverte am√©lior√© :
        // 1. Essayer de se connecter aux n≈ìuds pr√©d√©finis
        // 2. Propager la liste des pairs connus
        
        CONFIG.DISCOVERY_NODES.forEach(n => {
            const id = CONFIG.APP_PREFIX + n;
            if (n !== State.username && !State.connections.has(id)) {
                try {
                    const conn = State.peer.connect(id, { reliable: true });
                    if (conn) {
                        this.bindEvents(conn);
                    }
                } catch (e) {
                    // N≈ìud non disponible, silencieux
                }
            }
        });
        
        // Propager la liste des pairs connus aux pairs connect√©s
        // Cela permet la d√©couverte transitive : A conna√Æt B, B conna√Æt C, donc A d√©couvre C
        if (State.connections.size > 0) {
            const knownPeers = Array.from(State.connections.keys());
            this.broadcast({ 
                type: 'peer_discovery', 
                peers: knownPeers,
                origin: CONFIG.APP_PREFIX + State.username
            });
        }
    },
    
    // D√©couvrir de nouveaux pairs via un pair existant
    discoverPeer(peerId) {
        if (peerId === CONFIG.APP_PREFIX + State.username) return; // C'est moi
        if (State.connections.has(peerId)) return; // D√©j√† connect√©
        
        try {
            const conn = State.peer.connect(peerId, { reliable: true });
            if (conn) {
                this.log(`üîç D√©couverte: ${peerId.replace(CONFIG.APP_PREFIX, "")}`);
                this.bindEvents(conn);
            }
        } catch (e) {
            // √âchec silencieux
        }
    },

    getHashColor(str) {
        // G√©n√©rer un hash unique pour chaque string
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = str.charCodeAt(i) + ((hash << 5) - hash);
        }
        
        // Palette de couleurs vives et distinctes
        const colors = [
            0xFF6B6B, // Rouge corail
            0x4ECDC4, // Turquoise
            0xFFE66D, // Jaune dor√©
            0x95E1D3, // Vert menthe
            0xF38181, // Rose saumon
            0xAA96DA, // Violet pastel
            0xFCBF49, // Orange vif
            0x06FFA5, // Vert n√©on
            0xFF5E78, // Rose vif
            0x5B8DEF, // Bleu ciel
            0xFFAA00, // Orange ambre
            0x00D9FF, // Cyan √©lectrique
            0xFF6EC7, // Magenta
            0x7FFF00, // Vert chartreuse
            0xFF4757, // Rouge cerise
            0x48DBB4, // Vert √©meraude
            0xF7B731, // Jaune moutarde
            0x5F27CD, // Violet profond
            0x00D2D3, // Cyan profond
            0xFF9FF3  // Rose bonbon
        ];
        
        // S√©lectionner une couleur bas√©e sur le hash
        const index = Math.abs(hash) % colors.length;
        return colors[index];
    }
};

// UI Listeners
document.getElementById('btn-join').onclick = () => {
    const u = document.getElementById('username').value.trim();
    const p = document.getElementById('password').value;
    if (!u) return;
    
    if (u === 'admin' && p === 'root') State.isArchitect = true;
    
    document.getElementById('login-screen').classList.add('hidden');
    Network.init(u);
    Engine.renderer.domElement.requestPointerLock();
    // Initialiser l'UI du crosshair
    setTimeout(() => Network.updateLockUI(), 100);
};

Engine.init();
</script>
</body>
</html>